(function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t=t||self).tp={})})(this,function(t){;const e=[];for(let d=0;d<256;d++)e[d]=(d<16?"0":"")+d.toString(16);let s=1234567;const r={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){const t=4294967295*Math.random()|0,s=4294967295*Math.random()|0,r=4294967295*Math.random()|0,n=4294967295*Math.random()|0;return(e[255&t]+e[t>>8&255]+e[t>>16&255]+e[t>>24&255]+"-"+e[255&s]+e[s>>8&255]+"-"+e[s>>16&15|64]+e[s>>24&255]+"-"+e[63&r|128]+e[r>>8&255]+"-"+e[r>>16&255]+e[r>>24&255]+e[255&n]+e[n>>8&255]+e[n>>16&255]+e[n>>24&255]).toUpperCase()},clamp:function(t,e,s){return Math.max(e,Math.min(s,t))},euclideanModulo:function(t,e){return(t%e+e)%e},mapLinear:function(t,e,s,r,n){return r+(t-e)*(n-r)/(s-e)},lerp:function(t,e,s){return(1-s)*t+s*e},smoothstep:function(t,e,s){return t<=e?0:t>=s?1:(t=(t-e)/(s-e))*t*(3-2*t)},smootherstep:function(t,e,s){return t<=e?0:t>=s?1:(t=(t-e)/(s-e))*t*t*(t*(6*t-15)+10)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},seededRandom:function(t){return void 0!==t&&(s=t%2147483647),((s=16807*s%2147483647)-1)/2147483646},degToRad:function(t){return t*r.DEG2RAD},radToDeg:function(t){return t*r.RAD2DEG},isPowerOfTwo:function(t){return 0==(t&t-1)&&0!==t},ceilPowerOfTwo:function(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))},floorPowerOfTwo:function(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))},setQuaternionFromProperEuler:function(t,e,s,r,n){const i=Math.cos,o=Math.sin,h=i(s/2),c=o(s/2),u=i((e+r)/2),a=o((e+r)/2),l=i((e-r)/2),y=o((e-r)/2),p=i((r-e)/2),f=o((r-e)/2);switch(n){case"XYX":t.set(h*a,c*l,c*y,h*u);break;case"YZY":t.set(c*y,h*a,c*l,h*u);break;case"ZXZ":t.set(c*l,c*y,h*a,h*u);break;case"XZX":t.set(h*a,c*f,c*p,h*u);break;case"YXY":t.set(c*p,h*a,c*f,h*u);break;case"ZYZ":t.set(c*f,c*p,h*a,h*u);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+n)}}};class n{constructor(t=0,e=0){Object.defineProperty(this,"isVector2",{value:!0}),this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,s=this.y,r=t.elements;return this.x=r[0]*e+r[3]*s+r[6],this.y=r[1]*e+r[4]*s+r[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(t,Math.min(e,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,s=this.y-t.y;return e*e+s*s}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,s){return this.x=t.x+(e.x-t.x)*s,this.y=t.y+(e.y-t.y)*s,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e){return void 0===e&&(e=0),this.x=t[e],this.y=t[e+1],this}toArray(t,e){return void 0===t&&(t=[]),void 0===e&&(e=0),t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,s){return void 0!==s&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const s=Math.cos(e),r=Math.sin(e),n=this.x-t.x,i=this.y-t.y;return this.x=n*s-i*r+t.x,this.y=n*r+i*s+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}function i(){this.type="Curve",this.arcLengthDivisions=200}function o(t,e){const s=1-t;return s*s*e}function h(t,e){return 2*(1-t)*t*e}function c(t,e){return t*t*e}function u(t,e,s,r){return o(t,e)+h(t,s)+c(t,r)}function a(t,e){const s=1-t;return s*s*s*e}function l(t,e){const s=1-t;return 3*s*s*t*e}function y(t,e){return 3*(1-t)*t*t*e}function p(t,e){return t*t*t*e}function f(t,e,s,r,n){return a(t,e)+l(t,s)+y(t,r)+p(t,n)}function g(t,e,s,r){i.call(this),this.type="CubicBezierCurve",this.v0=t||new n,this.v1=e||new n,this.v2=s||new n,this.v3=r||new n}function v(t,e,s){i.call(this),this.type="QuadraticBezierCurve",this.v0=t||new n,this.v1=e||new n,this.v2=s||new n}function x(){i.call(this),this.type="CurvePath",this.curves=[],this.autoClose=!1}Object.assign(i.prototype,{getPoint:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null},getPointAt:function(t,e){const s=this.getUtoTmapping(t);return this.getPoint(s,e)},getPoints:function(t){void 0===t&&(t=5);const e=[];for(let s=0;s<=t;s++)e.push(this.getPoint(s/t));return e},getSpacedPoints:function(t){void 0===t&&(t=5);const e=[];for(let s=0;s<=t;s++)e.push(this.getPointAt(s/t));return e},getLength:function(){const t=this.getLengths();return t[t.length-1]},getLengths:function(t){if(void 0===t&&(t=this.arcLengthDivisions),this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let s,r=this.getPoint(0),n=0;e.push(0);for(let i=1;i<=t;i++)n+=(s=this.getPoint(i/t)).distanceTo(r),e.push(n),r=s;return this.cacheArcLengths=e,e},updateArcLengths:function(){this.needsUpdate=!0,this.getLengths()},getUtoTmapping:function(t,e){const s=this.getLengths();let r=0;const n=s.length;let i;i=e||t*s[n-1];let o,h=0,c=n-1;for(;h<=c;)if((o=s[r=Math.floor(h+(c-h)/2)]-i)<0)h=r+1;else{if(!(o>0)){c=r;break}c=r-1}if(s[r=c]===i)return r/(n-1);const u=s[r];return(r+(i-u)/(s[r+1]-u))/(n-1)},getTangent:function(t,e){let s=t-1e-4,r=t+1e-4;s<0&&(s=0),r>1&&(r=1);const i=this.getPoint(s),o=this.getPoint(r),h=e||(i.isVector2?new n:new Vector3);return h.copy(o).sub(i).normalize(),h},getTangentAt:function(t,e){const s=this.getUtoTmapping(t);return this.getTangent(s,e)},computeFrenetFrames:function(t,e){const s=new Vector3,n=[],i=[],o=[],h=new Vector3,c=new Matrix4;for(let r=0;r<=t;r++){const e=r/t;n[r]=this.getTangentAt(e,new Vector3),n[r].normalize()}i[0]=new Vector3,o[0]=new Vector3;let u=Number.MAX_VALUE;const a=Math.abs(n[0].x),l=Math.abs(n[0].y),y=Math.abs(n[0].z);a<=u&&(u=a,s.set(1,0,0)),l<=u&&(u=l,s.set(0,1,0)),y<=u&&s.set(0,0,1),h.crossVectors(n[0],s).normalize(),i[0].crossVectors(n[0],h),o[0].crossVectors(n[0],i[0]);for(let p=1;p<=t;p++){if(i[p]=i[p-1].clone(),o[p]=o[p-1].clone(),h.crossVectors(n[p-1],n[p]),h.length()>Number.EPSILON){h.normalize();const t=Math.acos(r.clamp(n[p-1].dot(n[p]),-1,1));i[p].applyMatrix4(c.makeRotationAxis(h,t))}o[p].crossVectors(n[p],i[p])}if(!0===e){let e=Math.acos(r.clamp(i[0].dot(i[t]),-1,1));e/=t,n[0].dot(h.crossVectors(i[0],i[t]))>0&&(e=-e);for(let s=1;s<=t;s++)i[s].applyMatrix4(c.makeRotationAxis(n[s],e*s)),o[s].crossVectors(n[s],i[s])}return{tangents:n,normals:i,binormals:o}},clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.arcLengthDivisions=t.arcLengthDivisions,this},toJSON:function(){const t={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t},fromJSON:function(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}),g.prototype=Object.create(i.prototype),g.prototype.constructor=g,g.prototype.isCubicBezierCurve=!0,g.prototype.getPoint=function(t,e){const s=e||new n,r=this.v0,i=this.v1,o=this.v2,h=this.v3;return s.set(f(t,r.x,i.x,o.x,h.x),f(t,r.y,i.y,o.y,h.y)),s},g.prototype.copy=function(t){return i.prototype.copy.call(this,t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this},g.prototype.toJSON=function(){const t=i.prototype.toJSON.call(this);return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t},g.prototype.fromJSON=function(t){return i.prototype.fromJSON.call(this,t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this},v.prototype=Object.create(i.prototype),v.prototype.constructor=v,v.prototype.isQuadraticBezierCurve=!0,v.prototype.getPoint=function(t,e){const s=e||new n,r=this.v0,i=this.v1,o=this.v2;return s.set(u(t,r.x,i.x,o.x),u(t,r.y,i.y,o.y)),s},v.prototype.copy=function(t){return i.prototype.copy.call(this,t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this},v.prototype.toJSON=function(){const t=i.prototype.toJSON.call(this);return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t},v.prototype.fromJSON=function(t){return i.prototype.fromJSON.call(this,t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this},x.prototype=Object.assign(Object.create(i.prototype),{constructor:x,getCurveIndex:function(t){const e=t*this.getLength(),s=this.getCurveLengths();let r=0;for(;r<s.length;){if(s[r]>=e)return s[r],this.curves[r].getLength(),r;r++}return null},add:function(t){this.curves.push(t)},closePath:function(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new Curves.LineCurve(e,t))},getPoint:function(t){const e=t*this.getLength(),s=this.getCurveLengths();let r=0;for(;r<s.length;){if(s[r]>=e){const t=s[r]-e,n=this.curves[r],i=n.getLength(),o=0===i?0:1-t/i;return n.getPointAt(o)}r++}return null},getLength:function(){const t=this.getCurveLengths();return t[t.length-1]},updateArcLengths:function(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()},getCurveLengths:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let s=0,r=this.curves.length;s<r;s++)e+=this.curves[s].getLength(),t.push(e);return this.cacheLengths=t,t},getSpacedPoints:function(t){void 0===t&&(t=40);const e=[];for(let s=0;s<=t;s++)e.push(this.getPoint(s/t));return this.autoClose&&e.push(e[0]),e},getPoints:function(t){t=t||12;const e=[];let s;for(let r=0,n=this.curves;r<n.length;r++){const i=n[r],o=i&&i.isEllipseCurve?2*t:i&&(i.isLineCurve||i.isLineCurve3)?1:i&&i.isSplineCurve?t*i.points.length:t,h=i.getPoints(o);for(let t=0;t<h.length;t++){const r=h[t];s&&s.equals(r)||(e.push(r),s=r)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e},copy:function(t){i.prototype.copy.call(this,t),this.curves=[];for(let e=0,s=t.curves.length;e<s;e++){const s=t.curves[e];this.curves.push(s.clone())}return this.autoClose=t.autoClose,this},toJSON:function(){const t=i.prototype.toJSON.call(this);t.autoClose=this.autoClose,t.curves=[];for(let e=0,s=this.curves.length;e<s;e++){const s=this.curves[e];t.curves.push(s.toJSON())}return t},fromJSON:function(t){i.prototype.fromJSON.call(this,t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,s=t.curves.length;e<s;e++){const s=t.curves[e];this.curves.push((new Curves[s.type]).fromJSON(s))}return this}}),t.CubicBezierCurve=g,t.CurvePath=x,t.QuadraticBezierCurve=v,Object.defineProperty(t,"__esModule",{value:!0})});